\chapter{A Better Mechanism: Bluetana}\label{chap:3}
\begin{quote}
``So, in the interests of survival, they trained themselves to be agreeing machines instead of thinking machines.
 All their minds had to do was to discover what other people were thinking, and then they thought that, too.'' \\ 
--- Kurt Vonnegut, \emph{Breakfast of Champions}
\end{quote}
In the last chapter, AZDWM documents revealed many skimming devices are Bluetooth enabled.
This motivated the development of an Android application, Bluetana, for skimmer detection.  
Bluetana was ultimately deployed to over twenty government investigators. 
The application was also responsible for the recovery of over 60 skimmers.
The fraud prevented is in the range of hundreds of thousands to millions of dollars 
(Section~\ref{sec:background-on-skimming}).
In this chapter, I detail the development of Bluetana.
I also detail the set of systems allowing for the application's crowd-sourced deployment.
For educational purposes, I also note some of the mistakes made during implementation.

Many features made Bluetana usable in the field by a modest number of inspectors.
This includes the implementation of a \emph{kiosk} mode. 
Kiosk mode made Bluetana the only accessible application on the phone.
This ensured inspectors didn't misuse the phones or accidentally close the application.
Another necessity were a fast, accessible-anywhere API endpoints.
This allowed us to push remote updates and get live reports from the phones.
To build this server, we cleverly leveraged existing consumer infrastructure.
Finally, I built caching mechanisms into the application for collected records. 
This guaranteed scan records would not be lost until they were successfully uploaded. 

Beyond implementation, this chapter details the front-end features added to the application.
Many of these systems were critical in spurring skimmer investigations during inspections. 
The chapter gives a full description of the mechanisms used highlighting suspicious devices.
These mechanisms are undergoing constant change, and must adapt as skimmers adapt.
Thus, I conclude with a discussion of correct classification.
Classification remains difficult due to the number of Bluetooth devices seen by inspectors.

\section{Related Work}

There do exist systems and tools currently on the market for skimmer detection.
One example, developed by Scaife et al., is SkimReaper, a device for detecting external skimmers
\cite{scaife2018fear}.
This credit-card shaped device can detect the second read head of external skimmers.
However, this device cannot detect internal skimmers.
Other skimmer detection apps leveraging Bluetooth also exist on the app store.
Scaife et al. reviewed these applications in a survey of skimmer protection mechanisms
\cite{scaife2019rogue}.
They found these applications use a limited feature set in detection.
The apps match potential skimmers by MAC, name, or attempting to connect.
Apps attempting to connect to the device are most concerning.
This can remove forensic evidence recording the last paired MAC address.

\section{Construction of an Application for Skimmer Detection}

Most of the ``skimmer detection" work is actually back-end data analysis.
Thus, the front-end design of a skimmer detection application is trivial. 
The application approximates a run-of-the-mill Bluetooth scanner. 
Bluetana consists of two pages, a scan page and settings page. 
The application consists of \numberofbluetanafiles code files and \numberoflinesbluetana lines in total. 
The primary page allows the user to choose to turn scanning on or off and show a list of nearby Bluetooth devices.

The settings page allows for the user to adjust the behavior of scanning and the application. 
Inspectors can set the app to scan only while the phone is connected to power. 
This makes starting a scan as easy as plugging the phone in and preserves battery.
Another option, to start the app at boot-up, makes data collection more robust.
By requiring less user interaction, we increase the probability that users scan.
The settings page also provides versioning metadata and several override switches.
These are provided in case there are bugs in the application.

\subsection{Key Limitations}

Using Android for skimmer detection has one major drawback.
Bluetooth Service Discovery Protocol (SDP) look-ups require a connection to the other device.
SDP features offered by a device are an effective method of fingerprinting 
\cite{wong2005potential}.
As mentioned above, connecting to a skimmer can destroy useful forensic evidence.
It may be possible to circumvent this restriction by sacrificing application stability.
Due to stability concerns, I did not implement these workarounds.

A key limitation to Bluetana specifically was the lack of constant geolocation recording.
Records were not recorded from gas stations with no Bluetooth devices.
Location recording could be used to better assess Bluetooth's prevalence.
For now, only stations with at least one measurable Bluetooth device appear in our analysis.

\subsection{The Benefits and Challenges of Crowdsourcing}

Detection of skimmers requires a significant amount of travel.
One must visit a large number of stations to find even a single skimmer. 
Thus, crowd-sourcing Bluetana was necessary for the completion of this study.
This required the applications adoption by the users and making the design easy to use.
It also required sophisticated mechanisms for remote updates from and to the phone.

Bluetan implements a seamless, infallible remote update mechanism.
On application boot, the phone makes an API query to our server for a new application version.
If one is found, the app attempts to download the new application if possible using Android's \texttt{DownloadManager} API.
This allows the app to resume downloading even with a shoddy connection.
The Play Store was avoided due to the sensitivity of the application.
Serving remote updates in this manner causes no issue beyond the initial install.
This initial install requires the user to ``enable untrusted apps". 
The application also checks for updates before closing if a fatal exception occurs.
In this case, the application can recover in case a broken update is pushed to the phones.

Another challenge is providing the API endpoints for file upload and download.
Coding these routes securely and efficiently takes time (and isn't much fun).
So facsimile endpoints were created by hosting files on Google Drive.
This requires some care in distribution and control of API keys.
However, these endpoints provided timestamps on data, dynamic content, and speedy hosting.
For research projects, this is a counter-intuitive but robust infrastructural route. 
A separate scraper can be written to parse uploaded files into a SQL database.
The Drive did start lagging on direct access from the \emph{browser} after some time.
Otherwise, no significant (non-ethical) issues were encountered using Drive in this manner.

Of Bluetana's front-end features, the most challenging to implement was a kiosk mode.
This mode makes Bluetana the only application accessible on the phone.
Kiosk mode prevents accidental exit from Bluetana and misuse of the phone.
Making a separate APK for this mode would complicate version control.
Thus, I implemented it as a dynamic feature of the application.
Bluetana looks for the existence of an inaccessible-without-root file to enter this mode.
It then swaps the APK's application manifest description to allow extended permissions. 
Complications arose in life-cycle management at startup.
Running an application as the home screen causes partial garbage-collection at inopportune times.
The application's initial implementation tied Bluetooth scanning to \emph{fragments} rather than \emph{services}.
Fragments are UI layers intended to be discarded.
Thus, background tasks should almost always be implemented as services. 
These are lifecycle-independent data producers which the UI can consume.
This led to more development time making Kiosk mode stable.

\section{Bluetooth Scanning Implementation}

The Android API's \texttt{BluetoothAdapter} class handles Bluetooth scanning.
Methods of this object allow semi-direct control of the phone's Bluetooth module.
Unfortunately, there are minor variations of this class for different hardware. 
I worked around these inconsistencies to make the application portable.

The Bluetooth adapter provides another class with Android \texttt{Intent} objects.
These intents provide a \texttt{BluetoothDevice} class object whenever a Bluetooth device is discovered.
Table~\ref{tab:bluetooth-device-fields} contains the functions and constants used for fingerprinting and localization. 
The class functions and their descriptions are from Android API site \cite{bluetoothDevice}.
Bluetana records this data into a CSV with~\numfieldsCSV~fields.
Metadata such as location and time discovered are also recorded into this CSV.

\begin{table}
  \centering
  \caption{
    Functions and constants provided by the Android API on device discovery.
    All the functions return immediately.
    However, \texttt{getName} can return \texttt{null} until the paging step of discovery is complete.
  }
  \label{tab:bluetooth-device-fields}
  \begin{tabular}{@{}lcr@{}}
    \toprule
    Field & Data & Type \\ \midrule
    getAddress() & Returns BluetoothDevice hardware address & String	 \\
    getBluetoothClass() & Get device Bluetooth class &  BluetoothClass	\\
    getName() & Get device Bluetooth name & String \\
    getType() & Get Bluetooth device type & int \\ 
    EXTRA\_RSSI & Extra field in intent for signal strength & String \\ \bottomrule
  \end{tabular}
\end{table}

\section{Collecting Information}

Bluetana collects data until the size of the CSV file reaches~\filesizebeforecompression.
At this point, the app compresses the file to around~\filesizeaftercompression~for upload.
The CSV is then added to an upload queue folder.
Once a data connection is established, these files are uploaded to the drive. 
They are then moved to a ``finished'' cache on the phone.
The drive is scraped every fifteen minutes for new files.
If there are any, the records contained within them are input to a PSQL database.

Additionally, Bluetana contains a ``hitlist'' it routinely downloads from the drive.
As new skimmer Bluetooth features are discovered, they are added to the hitlist.
Device records which match features on the hitlist are highlighted within the app
(Figure~\ref{fig:bluetana-highlight-screenshot}).
If the device is highlighted red, inspectors are instructed to try an localize it.
This increases the number of records collected for suspicious devices.

\begin{figure}
  \centering
  \includegraphics[width=4.25in]{pics/bluetana-highlight-screenshot.png}
  \caption{
    Screenshot of Bluetana's suspicious device highlighting.
    Highly suspicious devices are highlighted red.
    Less suspicious devices are highlighted orange or yellow.
  }
  \label{fig:bluetana-highlight-screenshot}
\end{figure}

A larger number of records helped to prevent false positives.
Using localization records, Bluetana was able to create heatmaps for each device
(Figure~\ref{fig:heatmap-localization}).
Skimmers will have a high signal strength close to a gas pump.

\begin{figure}
  \centering
  \includegraphics[width=4.25in]{pics/heatmap-localization.pdf}
  \caption{
    Screenshot comparing Bluetana's localization data between a skimmer and non-skimmer.
    Skimmers, unlike other devices, have much higher signal strength near the gas pump.
    Sensitive data has been redacted.
  }
  \label{fig:heatmap-localization}
\end{figure}
While other devices like car stereos may as well, this is less likely.

Live updates from each phone also allowed notifications to be created.
This allowed our research team to quickly respond to new suspicious devices.
It also allowed for the creation of a leaderboard and other metrics.
These were integrated into a web interface used in retroactive analysis
(Figure~\ref{fig:bluetana-website}).

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{pics/bluetana-website.png}
  \caption{
    Screenshot of Bluetana's web interface.
    The site includes a leaderboard as well as query engine for suspicious devices.
    Notifications of suspicious devices were pushed to team members via email.
  }
  \label{fig:bluetana-website}
\end{figure}

\subsection{Scan Time Reduction}

The application also has settings to reduce the Bluetooth scan time.
This helps to speed up device localization and records collected.
Prior research demonstrates a majority of devices are detected within 10 seconds of a Bluetooth scan
\cite{peterson2006bluetooth}.
However, this has two trade-offs.
The first being that the application may not scan both Bluetooth frequency trains.
These trains are used by devices during discovery to minimize signal conflicts
The second is that it prevents the device from performing some of the paging discovery stage.
This stage is used for transferring the device name to the scanning device
\cite{miller2001bluetooth}.
Due to these complications, inspectors phones were set to the android default scan time at startup.

\subsection{Suspicious Device Flagging}\label{sec:skimmer-flagging-workflow}

We designed Bluetana's method of highlighting suspicious devices based upon discovered skimmers.
Initially the hit-list contained information from the internet and existing applications
It then became clear inspectors were not finding Bluetooth Low Energy skimmers. 
All the discovered skimmers also had an unset Bluetooth device class
\footnote{A set of bytes used to indicate what a device is (phone, stereo, etc.).}
and uncustomized MAC addresses.
These features alone were effective in finding skimmers
(Figure~\ref{fig:plot-of-class-and-MAC-filtered}).
However, we also performed edit-distance clustering on the device names. 
This revealed known products and common default names. 
Figure~\ref{fig:flagging-flowchart} presents a flowchart of the current flagging workflow.

\begin{figure}
  \centering
  \includegraphics[width=4.25in]{plots/plot-of-class-and-MAC-filtered.png}
  \caption{
    Plot of the distribution of skimmers in the last stage of flagging.
    After MAC, Device class, and Bluetooth classic filtering few devices remain.
  }
  \label{fig:plot-of-class-and-MAC-filtered}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{plots/flagging-flowchart.pdf}
  \caption{
    Decision tree for determining how Bluetana highlights a device.
    Orange and red devices suggest the performance of localization or manual inspection.
  }
  \label{fig:flagging-flowchart}
\end{figure}

\section{Future Work and Open Problems}

Bluetana managed to detect 64 skimmers, but the problem is not solved.
Detection mechanisms could be extended to catch SMS-enabled skimmers. 
Figure~\ref{fig:bluetooth-or-gsm} demonstrates that these skimmers exist.
Additionally, persistent devices could be deployed for prevention.
For example, it may be possible RF bands for payment data transfers.
It may also be possible to detect the power draw from internal skimmers.
Criminals may also find ways of adapting their Bluetooth signature.
In this case, more sophisticated localization mechanisms may be needed.

The analysis routines of Bluetana itself also have room for improvement. 
We relied on inspector's discovery of ground-truth data for our analysis.
However, there may be skimmers they missed, exhibiting uncommon features. 
Notably, we did not analyze Bluetooth Low Energy modules in depth.
Additionally, SDP might be used to detect more well-hidden skimmers.
This would require developing workarounds for Android or low-cost embedded skimmer detection devices.

\section{Summary}

This chapter described the implementation of an Android application for skimmer detection.
This application, Bluetana, although simple, was able to discover 64 skimming devices
Beyond Bluetana, this chapter also gives some insight into crowd-sourced application design.
It notes the challenges in deploying an application to many users without the Play store.
Finally, it was important that the application was adaptable and robust. 
This allowed continuous improvement after field deployment.
In many ways, this was what allowed for Bluetana's success in skimmer detection.

\section{Acknowledgements}

Thank you to Aaron and Kirill for their motivation and guidance during development.
Thank you to Nishant for being a friend and the other half in deployment and data analysis.
Thank you to the thousands of unnamed engineers and scientists that made this project possible.
And finally, thank you to the lovely staff of the AZDWM for your use of our application.

Chapter 3, in part, is a reprint of the material as it appears in USENIX Security 2019.
Bhaskar, Nishant; Bland, Maxwell; Levchenko, Kirill; Schulman, Aaron, In proc. USENIX Security,
2019. The dissertation/thesis author was a primary investigator and author of this paper. 
