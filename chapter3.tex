\chapter{A Better Mechanism: Bluetana}\label{chap:3}
\section{Introduction}
In the last chapter, AZDWM documents revealed many skimming devices are Bluetooth enabled.
This motivated the development of an Android application, Bluetana, for skimmer detection.  
Bluetana was ultimately deployed to over twenty government investigators. 
The application was also responsible for the recovery of over 60 skimmers.
The fraud prevented is in the range of hundreds of thousands to millions of dollars 
(Section~\ref{sec:background-on-skimming}).
In this chapter, I detail the development of Bluetana.
I also detail the set of systems allowing for the application's crowd-sourced deployment.
For educational purposes, I also note some of the mistakes made during implementation.

Many features made Bluetana usable in the field by a modest number of inspectors.
This includes the implementation of a \emph{kiosk} mode. 
Kiosk mode made Bluetana the only accessible application on the phone.
This ensured inspectors didn't misuse the phones or accidentally close the application.
Another necessity were a fast, accessible-anywhere API endpoints.
This allowed us to push remote updates and get live reports from the phones.
To build this server, we cleverly leveraged existing consumer infrastructure.
Finally, I built caching mechanisms into the application for collected records. 
This guaranteed scan records would not be lost until they were successfully uploaded. 

Beyond implementation, this chapter details the front-end features added to the application.
Many of these systems were critical in spurring skimmer investigations during inspections. 
The chapter gives a full description of the mechanisms used highlighting suspicious devices.
These mechanisms are undergoing constant change, and must adapt as skimmers adapt.
Thus, I conclude with a discussion of correct classification.
Classification remains difficult due to the number of Bluetooth devices seen by inspectors.

\section{Related Work}

There do exist systems and tools currently on the market for skimmer detection.
One example, developed by Scaife et al., is SkimReaper, a device for detecting external skimmers
\cite{scaife2018fear}.
This credit-card shaped device can detect the second read head of external skimmers.
However, this device cannot detect internal skimmers.
Other skimmer detection apps leveraging Bluetooth also exist on the app store.
Scaife et al. reviewed these applications in a survey of skimmer protection mechanisms
\cite{scaife2019rogue}.
They found these applications use a limited feature set in detection.
The apps match potential skimmers by MAC, name, or attempting to connect.
Apps attempting to connect to the device are most concerning.
This can remove forensic evidence recording the last paired MAC address.

\section{Construction of an Android Application for Skimmer Detection}

Most of the ``skimmer detection" work is actually back-end data analysis.
Thus, the front-end design of a skimmer detection application is trivial. 
The application approximates a run-of-the-mill Bluetooth scanner. 
Bluetana consists of two pages, a scan page and settings page. 
In total, the application has \numberofbluetanafiles files and \numberoflinesbluetana lines of code. 
The primary page allows the user to choose to turn scanning on or off and show a list of nearby Bluetooth devices.

The settings page allows for the user to adjust the behavior of scanning and the application. 
Inspectors can set the app to scan only while the phone is connected to power. 
This makes starting a scan as easy as plugging the phone in and preserves battery.
Another option, to start the app at boot-up, makes data collection more robust.
By requiring less user interaction, we increase the probability that users scan.
The settings page also provides versioning metadata and several override switches.
These are provided in case there are bugs in the application.

\subsection{Key Limitations}

Using Android for skimmer detection has one major drawback.
Bluetooth Service Discovery Protocol (SDP) look-ups require a connection to the other device.
SDP features offered by a device are an effective method of fingerprinting 
\cite{wong2005potential}.
As mentioned above, connecting to a skimmer can destroy useful forensic evidence.
It may be possible to circumvent this restriction by sacrificing application stability.
Due to stability concerns, I did not implement these workarounds.

A key limitation to Bluetana specifically was the lack of constant geolocation recording.
Records were not recorded from gas stations with no Bluetooth devices.
Location recording could be used to better assess Bluetooth's prevalence.
For now, only stations with at least one measurable Bluetooth device appear in our analysis.

\subsection{The Benefits and Challenges of Crowdsourcing}

Detection of skimmers requires a significant amount of travel.
One must visit a large number of stations to find even a single skimmer. 
Thus, crowd-sourcing Bluetana was necessary for the completion of this study.
This required the applications adoption by the users and making the design easy to use.
It also required sophisticated mechanisms for remote updates from and to the phone.

Bluetan implements a seamless, infallible remote update mechanism.
On application boot, the phone makes an API query to our server for a new application version.
If one is found, the app attempts to download the new application if possible using Android's \texttt{DownloadManager} API.
This allows the app to resume downloading even with a shoddy connection.
The Play Store was avoided due to the sensitivity of the application.
Serving remote updates in this manner causes no issue beyond the initial install.
This initial install requires the user to ``enable untrusted apps". 
The application also checks for updates before closing if a fatal exception occurs.
In this case, the application can recover in case a broken update is pushed to the phones.

Another challenge is providing the API endpoints for file upload and download.
Coding these routes securely and efficiently takes time (and isn't much fun).
So facsimile endpoints were created by hosting files on Google Drive.
This requires some care in distribution and control of API keys.
However, these endpoints provided timestamps on data, dynamic content, and speedy hosting.
For research projects, this is a counter-intuitive but robust infrastructural route. 
A separate scraper can be written to parse uploaded files into a SQL database.
The Drive did start lagging on direct access from the \emph{browser} after some time.
Otherwise, no significant (non-ethical) issues were encountered using Drive in this manner.

Of Bluetana's front-end features, the most challenging to implement was a kiosk mode.
This mode makes Bluetana the only application accessible on the phone.
Kiosk mode prevents accidental exit from Bluetana and misuse of the phone.
Making a separate APK for this mode would complicate version control.
Thus, I implemented it as a dynamic feature of the application.
Bluetana looks for the existence of an inaccessible-without-root file to enter this mode.
It then swaps the APK's application manifest description to allow extended permissions. 
Complications arose in life-cycle management at startup.
Running an application as the home screen causes partial garbage-collection at inopportune times.
The application's initial implementation tied Bluetooth scanning to \emph{fragments} rather than \emph{services}.
Fragments are UI layers intended to be discarded.
Thus, background tasks should almost always be implemented as services. 
These are lifecycle-independent data producers which the UI can consume.
This led to more development time making Kiosk mode stable.

\section{Bluetooth Scanning Implementation}

The Android API's \texttt{BluetoothAdapter} class handles Bluetooth scanning.
Methods of this object allow semi-direct control of the phone's Bluetooth module.
Unfortunately, there are minor variations of this class for different hardware. 
I worked around these inconsistencies to make the application portable.

The Bluetooth adapter provides another class with Android \texttt{Intent} objects.
These intents provide a \texttt{BluetoothDevice} class object whenever a Bluetooth device is discovered.
Table~\ref{tab:bluetooth-device-fields} contains the functions and constants used for fingerprinting and localization. 
The class functions and their descriptions are from Android API site \cite{bluetoothDevice}.
Bluetana records this data into a CSV with~\numfieldsCSV~fields.
Metadata such as location and time discovered are also recorded into this CSV.

\begin{table}
  \centering
  \begin{tabular}{@{}lcr@{}}
    \toprule
    Field & Data & Type \\ \midrule
    getAddress() & Returns the hardware address of this BluetoothDevice & String	 \\
    getBluetoothClass() & Get the Bluetooth class of the remote device &  BluetoothClass	\\
    getName() & Get the friendly Bluetooth name of the remote device & String \\
    getType() & Get the Bluetooth device type of the remote device & int \\ 
    EXTRA\_RSSI & Used as an optional short extra field in ACTION\_FOUND intents & String \\ \bottomrule
  \end{tabular}
  \caption{
    Functions and constants provided by the Android API on device discovery.
    All the functions return immediately.
    However, \texttt{getName} can return \texttt{null} until the paging step of discovery is complete.
  }
  \label{tab:bluetooth-device-fields}
\end{table}

\section{Collecting Information}

Bluetana collects data until the size of the CSV file reaches~\filesizebeforecompression.
At this point, the app compresses the file to around~\filesizeaftercompression~for upload.
The CSV is then added to an upload queue folder.
Once a data connection is established, these files are uploaded to the drive. 
They are then moved to a ``finished'' cache on the phone.
The drive is scraped every fifteen minutes for new files.
If there are any, the records contained within them are input to a PSQL database.

Additionally, Bluetana contains a ``hitlist'' it routinely downloads from the drive.
As new skimmer Bluetooth features are discovered, they are added to the hitlist.
Device records which match features on the hitlist are highlighted within the app
(Figure~\ref{fig:bluetana-highlight-screenshot}).
If the device is highlighted red, inspectors are instructed to try an localize it.
This increases the number of records collected for suspicious devices.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{pics/bluetana-highlight-screenshot.png}
  \caption{
    Screenshot of Bluetana's suspicious device highlighting.
    Highly suspicious devices are highlighted red.
    Less suspicious devices are highlighted orange or yellow.
  }
  \label{fig:bluetana-highlight-screenshot}
\end{figure}

A larger number of records helped to prevent false positives.
Using localization records, Bluetana was able to create heatmaps for each device
(Figure~\ref{fig:heatmap-localization}).
Skimmers will have a high signal strength close to a gas pump.
While other devices like car stereos may as well, this is less likely.

Live updates from each phone also allowed notifications to be created.
This allowed our research team to quickly respond to new suspicious devices.
It also allowed for the creation of a leaderboard and other metrics.
These were integrated into a web interface used in retroactive analysis
(Figure~\ref{fig:bluetana-website}).

\subsection{Scan Time Reduction}

The application also has settings to reduce the Bluetooth scan time.
This helps to speed up device localization and records collected.
Prior research demonstrates a majority of devices are detected within 10 seconds of a Bluetooth scan
\cite{}.
However, this has two trade-offs.
The first being that the application may not scan both Bluetooth frequency trains.
These trains are used by devices during discovery to minimize signal conflicts
\cite{}.
The second is that it prevents the device from performing some of the paging discovery stage.
This stage is used for transferring the device name to the scanning device
\cite{}.
Due to these complications, inspectors phones were set to the android default scan time at startup.

\subsection{Data Visualization and Analysis Design}

Once the data was collected by Bluetana, it was stored in a PSQL database, and \numfilesfordataanalysis seperate scripts were used for a combination of exploratory data analysis and the statistics which were finally used within \cite{}.
In the end, the website as well as notification system noted above were created, and several different plots and data analysis methods were attempted in order to explicate features of potential skimmers.
These included dendrograms based upon device name edit distance clustering (Figure~\ref{fig:devname-dendrogram}), and inaccurate CDFs which looked at the overall distribution of Bluetooth device characteristics without taking into account abnormalities in the dataset or how the data was collected (Figure~\ref{fig:example-bad-cdf}).
As we refined our understanding of the features that actually classified skimming devices, we were able to more accurately hone in on the deductive mechanism for skimmer detection presented in Figure~\ref{fig:skimmer-detect-flowchart}, and begin to produce more relevant plots which looked specifically at gas station visits and relevant features, such as Figure~\ref{fig:uncat-hist}.

The data was stored in a PSQL database, and important lesson were learned about reducing thec complexity of joins, removing null records, and creating indices early on throughout the entire process.
Ultimately, the scripts used to generate the plots in the paper became one, rather complicated connection of several interelated components casting the data through different filters.
Reflecting on this process, research often results in messy, improvisational-jazz style code.
The entropy required by exploration and not neccessarily perfection should be embraced, but if one can document their thoughts along the way, these scripts can be studied, corrected, and modified more easily.
A sample of some of the code is provided in Figure~\ref{fig:messy-improv-code}.

\section{Skimmer Flagging Workflow}\label{sec:skimmer-flagging-workflow}

Detail the flow chart, maybe use the section of the paper that goes over this?

\section{Potential Drawbacks and Difficulties with Future Skimmer Detection}

There are a few potential drawbacks to the approach of using Android to develop a skimmer detection application.
The first is the inability to expand detection to wireless mechanisms beyond Bluetooth and Wifi without rooting the phone, as the API provides no direct control of the phone's antennaes.
Another drawback is the restrictions and ambiguities introduced by the Android API, such as the paging and name request portions of the bluetooth protocol, as outlined in Section~\ref{sec:name-request-sect}, though this may be circumventable via native code modules.

Additional difficulties arise from the use of Bluetooth itself, as not all skimmers are using Bluetooth for data retrieval, and some may develop mechanisms for cleverly hiding their Bluetooth signal, such as non-discoverable mode \cite{}.
Future internal skimmer detection mechanisms may need to rely on features intrinsic to the pump itself, such as current draw on the ribbon wire connecting the magnetic stripe reader to the Point-of-Sale terminal, or power glitching attacks.
Persistent solutions which monitor the wireless spectrum for sensitive data in transit may also be neccessary to establish.
In the end, the primary difficulties with Skimmer detection are that criminals will continue to adapt, or may move to different mechanisms of fraud altogether.

\subsection{Correct Classification}

There are also difficulties, even with the Bluetooth-based approach, in the correct classification of skimmers as skimmers: during the study of \cite{}, there were some cases wherein a skimmer was not classified as a skimmer until several months after the fact.
It is most likely the case that there are still skimmers in the dataset of devices we have recovered which are unrecovered.
The problem, however, is not one of adding additional parameters: Bluetooth as a standard only has so many, it may also be a problem of data analysis.
Complex multifactor systems such as this need more accessible, robust ways of measuring weighted distance between factors, and determining where outliers are without requiring an additional year of research on top of the year of research required to collect the data in the first place.
In this work, we attempted and were successful at finding many skimmers, proving that Bluetooth is an effective mechanism, but were unsuccessful at solving the much more complex problem of multifactor exploratory data analysis.
A general approach to this problem involving the collection of descriptive statistics for all features of the data, and then doing a dynamic search for outliers based upon different weightings of the features has no doubt been adopted already in other places.
This was a major drawback of Bluetana's approach: it was non-rigorous in its total analysis (as the majority of research projects are), and thus, in many ways ``got lucky" by relying on the heuristic mechanisms and inferences of the data's human operators.

\subsection{Information Overload}

Fundamentally, one issue of skimmer detection is information overload.
Skimmers are impactful but rare in comparison to the total number of gas stations and data points, and it therefore becomes difficult to explore the data without it being a waste of time.
The notification system helped to isolate some key instances of devices for further analysis, but more sophisticated systems of information isolation will be needed in order to fulfill the needs of future skimmer detection applications as well as other applications, such as those for program analysis, which may be searching for rare occurences within a program which have incredibly high impact.

\section{Open Problems}

Beyond the issue of skimming, the large open problem, introduced by the last section, is the creation of systems for efficient, human-usable, and accurate multifactor exploratory data analysis.
A generalized system or programming language which provides the user a toolkit for doing these tasks would lead to a more robust basis for the performance of research in complex systems, and allow for the development of applications which work within these systems to solve problems that rely on fine-grained classification of individuals within a population.
Training machine learning models is another approach, but these models are not easily adapted to new domains without a significant amount of training input.

The tantamount issue is skimming itself: the development of Bluetana did not solve the problem of skimming.
It provided an avenue of detection which will be circumvented at some point in the future.
For now, Bluetooth remains effective in the detection of skimming devices, however, as time progesses, it will be neccessary to develop mechanisms for the detection of internal skimmers with no noticable wireless signal other than at the time of data retrieval.
For now, progress could be made in the expansion of the methods used by Bluetana into low-cost, custom-built devices for skimmer detection.
These devices could have no more cost than a skimmer itself, and would be able to take advantage of features not offered by Android, such as SDP lookup without connection.
More intelligent inference of gas pump location for signal strength localization could also help to identify skimmers within the pump.
Finally, persistent, low-failure, and low-cost mechanisms for skimmer detection and prevention are the most promising area of future work.

\section{Summary}

There were several unmentioned implementation details which were critical to Bluetana's success, and indicative of potential future work, which were not present in the original paper.
These included some of the key limitations involved with the application's design.
These drawbacks were tempered by a few of the features which made the application deployable to a reasonable number investigators in a short period of time.
Also discussed were many features of the Android SDK API, which may be useful errata for anyone attempting to develop a crowdsourced application in the future.
Finally, this section detailed some of the back end mechanisms and challenges involved in supporting the Bluetana infrastructure, such as the use of Google Drive as a secure API end-point and the complexity of the data analysis task.

\section{Acknowledgements}
